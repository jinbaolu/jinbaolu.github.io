(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{442:function(t,a,s){"use strict";s.r(a);var r=s(29),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"前端挣扎史"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端挣扎史"}},[t._v("#")]),t._v(" 前端挣扎史")]),t._v(" "),s("blockquote",[s("p",[t._v("本文纯属瞎吹逼，如有写错，那我也不管了。")])]),t._v(" "),s("h2",{attrs:{id:"c-s-架构与-b-s-架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-s-架构与-b-s-架构"}},[t._v("#")]),t._v(" c/s 架构与 b/s 架构")]),t._v(" "),s("p",[t._v("客户端架构与浏览器架构，我相信互联网发展初期肯定很多都是客户端架构，因为当时前端及浏览器乃至计算机计算能力还没有特别成熟，因此，需要实现大多数的功能还是需要靠下载安装客户端，通过客户端与服务器进行数据交互，来实现信息数据传递的目的。"),s("br"),t._v("\n当然随着浏览器兴起，更多的应用可以使用网页去完成，去实现，好处就是方便，当客户端需要更新的时候，需要用户手动选择，时间成本大，而 b/s 则不同，开发者想更新就更新，即使有缓存也可以通知用户刷新清除缓存。")]),t._v(" "),s("h2",{attrs:{id:"我所认识的初代网页"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#我所认识的初代网页"}},[t._v("#")]),t._v(" 我所认识的初代网页")]),t._v(" "),s("p",[t._v("最初代网页应该是 html、css 标准贫乏，网页丑陋，内容展示单一，功能贫乏，所谓请求，也仅仅是在网络应用层，请求数据包按照 http 协议格式返回，并且由浏览器依据仅有的标准渲染。")]),t._v(" "),s("h2",{attrs:{id:"稍微有点功能的网页"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#稍微有点功能的网页"}},[t._v("#")]),t._v(" 稍微有点功能的网页")]),t._v(" "),s("p",[t._v("这个时候的网页，应该是我 15 年上大学时的网页，当时 php、jsp、.net 技术盛行。"),s("br"),t._v("\n因为信息处理的要求，服务器返回数据可变化，因此，服务器开始承接这变化的数据，这部分数据由后端使用特定方式去插入，由于这部分功能太繁杂，因此还不能承接大量变化的数据交互。")]),t._v(" "),s("h2",{attrs:{id:"功能相对健全的网页"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#功能相对健全的网页"}},[t._v("#")]),t._v(" 功能相对健全的网页")]),t._v(" "),s("p",[t._v("此时网页的发展应该是比较成熟，解决上一个阶段的不足，前端岗位应该出现了，只是当时前端的职责更多是将 ui 还原给后端，并特定地方提供插槽供后端更新数据，所以说当时也用涌现一批后端用的前端框架，基本也是一些封装好的前端组件类似的，这个阶段应该不太久远，18 年应该还在吧，同时我记得那时 thinkphp 还是很火，mvc 架构，很好区分代码逻辑，同时也衍生出一些小框架，类似 template.js 等框架，主要作用就是更好的讲数据插入到 html 中，还有一些小小的构建工具，例如 gulp 之类。"),s("br"),t._v("\n总的来说这些技术都不太久远，也就几年前的技术，甚至还不算落后，我也不知道要不要单独划分出来，只是觉得当时前后端并没有好好的分离，例如 thinkphp 的 view 层其中还夹杂这后端数据。")]),t._v(" "),s("h2",{attrs:{id:"当代最流行的网页"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当代最流行的网页"}},[t._v("#")]),t._v(" 当代最流行的网页")]),t._v(" "),s("p",[t._v("此时说的应该就是现在，在各种 html5、css3、以及 es6、还有旧 ie 推出舞台的这些种种背景下，前端也迎来一个非常重要的概念--“工程化”，好家伙，从初代网页一路过来，前端的职责慢慢剥离，到现在，前端项目逐渐形成工程概念，往标准靠拢。无可厚非，前端发展到现在，与各项技术发展不无关系，其中 webpack、vue、react 这类工具，同时前后端分离更加彻底，新的标准能完成的功能更多。")]),t._v(" "),s("h2",{attrs:{id:"工程化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工程化"}},[t._v("#")]),t._v(" 工程化")]),t._v(" "),s("p",[t._v("说到底，网页的本质还是老三剑客，工程化的概本质就是构建三剑客，至于如何构建、以及如何按照标准的去创建，可以说各家有各家的技术，本人认为所有的新兴技术都必定有一定需求才会出现，对于工程化，那需求就是前端技术萌芽发展到一个新的台阶，基本围绕着组件化、单页面路由、打包编译、插件化等等，此外，提供最大技术支持当然除不开全球的 javascript 开发者、node 包管理 npm，进一步推动了前端生态圈发展。")])])}),[],!1,null,null,null);a.default=e.exports}}]);